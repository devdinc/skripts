# todo registration process should use parse of event, skript reflect has bugs so we are waiting for an update
# todo tests should be isolated between .sk files, so before/after is triggered only if a test within that script is running, need to do parse first
# todo all tests within %script%, remove with test name, need to do parse first
using reflection

import:
    ch.njol.skript.lang.parser.ParserInstance
    org.bukkit.Bukkit
    ch.njol.skript.test.utils.TestOfflinePlayer
    ch.njol.skript.lang.Condition
    ch.njol.skript.test.runner.TestTracker
    ch.njol.skript.log.SkriptLogger

local effect sendTestFailMessage %string%[, %-string%]:
    trigger:
        set {_msg} to " %expr-2%" if expr-2 is set else ""
        send "[<gold>Skript<reset>] [&cTEST FAILURE<reset>] %expr-1%%{_msg}%" to console

event "skriptTest":
    pattern: [devdinc] test %string% [when <(.+)>]
    event-values: string, boolean
    check:
        set {_ok} to true
        set {-test.sk::tests::%expr-1%} to "%expr-1%"
        if "%expr-1%" is event-string:
            set {_raw} to first element of regex-1
            if {_raw} is set:
                set {_cond} to Condition.parse({_raw}, "Can't understand condition: " + {_raw})
        
            if {_cond} is set:
                set {_ok} to {_cond}.check(event)
            continue if {_ok} is true
            
event "beforeSkriptTest":
    pattern: [devdinc] before each test
    event-values: string, boolean
    check:
        continue
        
event "afterSkriptTest":
    pattern: [devdinc] after each test
    event-values: string, boolean
    check:
        continue
        
event "beforeSkriptTestAll":
    pattern: [devdinc] before all tests
    check:
        continue
        
event "afterSkriptTestAll":
    pattern: [devdinc] after all tests
    check:
        continue

plural expression all tests [with test name %-string%]:
    return type: strings
    parse:
        set {_scoped} to false if expr-2 is not set
        continue

    get:
        if {_scoped} is false:
            loop {-test.sk::tests::*}:
                if any:
                    expr-1 is not set
                    loop-value is expr-1
                then:
                    add "%loop-value%" to {_r::*}
        else:
            if {-test.sk::tests::%expr-1%} is set:
                add "%expr-1%" to {_r::*}

        return {_r::*}
        
effect (1:|2:auto)run [test][s] %strings%:
    trigger:
        set {_tests::*} to expr-1
        set {_alltests::*} to all tests
        call custom event "beforeSkriptTestAll"
        loop {_tests::*}:
            set {_list::string} to loop-value
            set {_list::boolean} to true if parse mark is 2 else false
            call custom event "beforeSkriptTest" with {_list::*}
            call custom event "skriptTest" with {_list::*}
            call custom event "afterSkriptTest" with {_list::*}
            if any:
                loop-value contains "f39f0f4a-31ee-4b71-87e9-38ddba3a2313"
                {_alltests::*} does not contain loop-value
            then:
                add 1 to {_forgottenTestResults}
                continue loop
            add 1 to {_testFails} if size of {-test.sk::errors::%loop-value%::*} is greater than 0
        call custom event "afterSkriptTestAll"
        set {_validTestAmount} to size of {_tests::*} - {_forgottenTestResults}
        if {_validTestAmount} is not 0:
            send "[<gold>Skript<reset>] <yellow>%{_validTestAmount} - {_testFails}%/%{_validTestAmount}% tests passed." to console
        else if size of {_alltests::*} is greater than 0: # skipping if there is no initial hidden test 
            send "[<gold>Skript<reset>] <yellow>No tests found." to console

condition last test result [of [test] %-string%] is a (1:pass|2:fail):
    usable in:
        custom event "skriptTest"
    check:
        if expr-1 is not set:
            set {_test} to event.getEventValue("string")
        else:
            set {_test} to expr-1
            stop if all tests does not contain expr-1
        if all:
            parse mark is 1
            size of {-test.sk::errors::%{_test}%::*} <= 0
        then:
            continue
        else:
            if all:
                parse mark is 2
                size of {-test.sk::errors::%{_test}%::*} > 0
            then:
                continue

before each test:
    delete {-test.sk::errors::%event-string%::*} 
    set {-test.sk::testblock} to test-block's type
    
after each test:
    set test-block to {-test.sk::testblock}

on load:
    delete {-test.sk::*}
    wait 1 tick
    run test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313"
    wait 1 tick
    set {_tests::*} to all tests
    autorun {_tests::*}

effect:
    patterns:
        (3:|4:(no|without) (halt[ing]|fail[(-| )](safe|fast)|abort[ing])) assert(1:|1: true|2: false)[ with (6:|5:no )[[error] message][ %-string%]]\: <(.+)>
        (3:|4:(no|without) (halt[ing]|fail[(-| )](safe|fast)|abort[ing])) assert <(.+)> (1:|2:to fail)[ with (6:|5:no )[[error][ message]][ %-string%]]
    usable in:
        custom event "skriptTest"
    parse:
        set {_raw} to first element of regex-1
        set {_origin} to SkriptLogger.getNode()
        set {_currentscript} to script ({_origin}.getConfig().getFileName())
        
        set {_parser} to ParserInstance.get()
        set {_parser}.[ParserInstance]isActive to true
        set {_backup} to {_parser}.backup()  
        
        {_parser}.setCurrentScript({_currentscript})
        {_parser}.setCurrentEvent("assert condition", (custom event "skriptTest").getClass())
        
        set {_cond} to Condition.parse({_raw}, "Can't understand condition: " + {_raw})
        
        set {_parser}.[ParserInstance]isActive to false
        {_parser}.restoreBackup({_backup})  
        continue
    trigger:
        set {_ok} to {_cond}.check(event)
        
        set {_label} to "assert true" if parse tags contains "1" else "assert false"
        set {_test} to event.getEventValue("string")
        if all:
            parse tags contains "1"
            {_ok} is false
        then:
            set {_bool1} to true
            
        if all:
            parse tags contains "2"
            {_ok} is true
        then:
            set {_bool2} to true
            
        if any:
            {_bool1} is true
            {_bool2} is true
        then:
            if parse tags does not contain "5":
                sendTestFailMessage "Test ""%{_test}%"" with condition '%{_label}%: %{_raw}%' failed", expr-1
            TestTracker.testFailed(expr-1)
            add "%expr-1%" to {-test.sk::errors::%{_test}%::*}
            if parse tags contains "3":
                delay effect

effect (3:|4:(no|without) (halt[ing]|fail[(-| )](safe|fast)|abort[ing])) fail test[ with (6:|5:no )[[error] message][ %-string%]]:
    usable in: 
        custom event "skriptTest"
    trigger:
        set {_test} to event.getEventValue("string")
        if parse tags does not contain "5":
            sendTestFailMessage "Test ""%{_test}%"" failed", expr-1
        TestTracker.testFailed(expr-1)
        add "%expr-1%" to {-test.sk::errors::%{_test}%::*}
        if parse tags contains "3":
            delay effect
        
effect stop auto [test] execution [here]:
    usable in:
        custom event "skriptTest"
    trigger:
        set {_bool} to event.getEventValue("boolean")
        if {_bool} is true:
            delay effect
            
expression [event(-| )]test:
    return type: string
#    usable in:
#        custom event "skriptTest"
    get:
        return event.getEventValue("string")
        
condition %string% (1:is|2:is not|2:isn't) autorun:
    # usable in:
    #    custom event "skriptTest"
    check:
        set {_bool} to event.getEventValue("boolean")
        if {_bool} is true:
            parse mark is 1
            continue
        else:
            parse mark is 2
            continue
            
import:
    ch.njol.skript.ScriptLoader
            
condition parse:
    parse:
        set {_parser} to ParserInstance.get()
        set {_parseSection} to {_parser}.getNode()
        set {_parseBackup} to {_parser}.backup()
        # nodes are not fully loaded here yet
        continue
    usable in:
        custom event "skriptTest"
    check:
        {_parser}.restoreBackup({_parseBackup})
        set {_logger} to SkriptLogger.startRetainingLog()
        ScriptLoader.loadItems({_parseSection})
        clear {-test.sk::latestLogs::*}
        loop ...{_logger}.getLog():
            add loop-value.getMessage() to {_logs::*}
        set {-test.sk::latestLogs::*} to {_logs::*}
        {_logger}.close()
        {_parser}.reset()
        
local effect no errors\: <.+>:
    trigger:
        stop

plural expression last parse logs:
    usable in:
        custom event "skriptTest"
    get:
        return {-test.sk::latestLogs::*}

plural expression test errors[ for [test[s]] %-strings%]:
    return type: strings
    get:
        if expr-1 is not set:
            set {_test} to event.getEventValue("string")
            return {-test.sk::errors::%{_test}%::*}
        else:
            loop ...expr-1:
                set {_test} to loop-value
                add {-test.sk::errors::%{_test}%::*} to {_r::*}
            return {_r::*}

expression [the] test(-| )world:
    return type: world
    get:
        set {_world} to Bukkit.getWorld("skripttest")
        if any:
            {_world} is not set
            {_world} is null
        then:
            return Bukkit.getWorlds().get(0)
        else:
            return {_world}

expression [the] test(-| )location:
    return type: location
    get:
        return test-world.getSpawnLocation().add(10, 1, 0)

expression [the] test(-| )block:
    return type: block
    get:
        return test-location.getBlock()
    set:
        set block at test-location to change value
        
expression [the] test(-| )offline[-| ]player:
    return type: offlineplayer
    get:
        set {_instance} to new TestOfflinePlayer()
        # TestOfflinePlayer.[TestOfflinePlayer]PLAYER_PROFILE.setProperty(new ProfileProperty("textures", "ewogICJ0aW1lc3RhbXAiIDogMTc0NzQyOTg2MTQwOCwKICAicHJvZmlsZUlkIiA6ICI2OWUzNzAyNjJjN2Q0MjU1YWM3NjliMTNhNWZlOGY3NCIsCiAgInByb2ZpbGVOYW1lIiA6ICJTYWh2ZGUiLAogICJzaWduYXR1cmVSZXF1aXJlZCIgOiB0cnVlLAogICJ0ZXh0dXJlcyIgOiB7CiAgICAiU0tJTiIgOiB7CiAgICAgICJ1cmwiIDogImh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvNTE2MGFiZWVhNDI1YzZmODMyYjc0NmE0NTQ0YzVmYjlhOTgxYjAyZTFiZDg1ZmVhNWM3ZWY4MzFiZGM4NzRmMyIKICAgIH0KICB9Cn0="));
        return {_instance}

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 assert true passes":
    assert true: {_none} is not set

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 assert false passes":
    assert false: {_none} is set
    
devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 framework internal consistency":
    without halting assert true: size of all tests > 0
    without halting assert true: "%current script%" is set
    assert true: size of test errors is 0


devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 assert true failure is recorded":
    without halting assert true with no error message: {_none} is set
    assert true: size of test errors is 1
    
devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 assert error message is stored":
    without halting assert true with no error message "msg1": {_none} is set
    assert true with message "check failed": test errors contains "msg1"

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 no error message produces empty suffix":
    without halting assert true with no error message: {_none} is set
    assert true: size of test errors is 1

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 halting assert stops execution":
    assert true with no error message: {_none} is set
    broadcast "<red>ERROR: this should never execute"

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 without halting continues execution":
    without halting assert true with no error message: {_none} is set
    assert true: {_none} is not set

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 fail test records error":
    without halting fail test with no error message
    assert true: size of test errors is 1

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 fail test halts by default":
    fail test with no error message
    broadcast "<red>ERROR: fail test did not halt"

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 autorun flag is true":
    if event-test is not autorun:
        stop
    assert true: event-test is autorun

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 manual run flag is false" when {_none} is set:
    fail test
    
devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 manual run flag" when event-test is not autorun:
    fail test if event-test is autorun

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 stop auto execution works":
    if event-test is not autorun:
        stop
    stop auto test execution here
    broadcast "<red>ERROR: auto execution not stopped"

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 all tests returns this test":
    set {_all::*} to all tests
    assert true: {_all::*} contains "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 all tests returns this test"

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 all tests":
    set {_all::*} to all tests
    assert true: size of {_all::*} > 0

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 errors do not leak between tests A":
    without halting assert true with no message: {_none} is set
    assert true: size of test errors is 1

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 errors do not leak between tests B":
    assert true: size of test errors is 0

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 event-test returns correct name":
    assert true: event-test is event-string
    
devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 test-block is temporary A":
    set {-test.sk::temptestblocka} to test-block's type
    test block is chest:
        set test-block to trapped chest
    else if test block is trapped chest:
        set test-block to chest
    else:
        set test-block to ender chest
    set {-test.sk::temptestblockb} to test-block's type
    
devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 test-block is temporary B":
    assert true: {-test.sk::temptestblocka} is test-block's type
    assert true: {-test.sk::temptestblocka} is not {-test.sk::temptestblockb}
    
devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 parse section":
    parse:
        no errors: abc # just an internal stuff to make sure test.sk loads without errors
    assert last parse logs contains "Can't understand this condition/effect: no errors: abc"

devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 last test result A":
    fail test with no error message
    
devdinc test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 last test result B":
    set {_test} to "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 last test result A"
    assert true: last test result of {_test} is a fail
