import:
    org.bukkit.NamespacedKey
    org.bukkit.persistence.PersistentDataContainer
    org.bukkit.persistence.PersistentDataHolder
    org.bukkit.persistence.PersistentDataType
    java.io.ByteArrayInputStream
    java.io.ByteArrayOutputStream
    org.bukkit.util.io.BukkitObjectInputStream
    org.bukkit.util.io.BukkitObjectOutputStream
    ch.njol.skript.lang.Variable

local function validate_pdcexpr(key: object, pdc: object, pdt: object) :: boolean:
    if all:
        {_pdt} is set
        {_pdt} is not an instance of PersistentDataType
    then:
        return false
    if any:
        {_key} is not an instance of NamespacedKey
        {_pdc} is not an instance of PersistentDataContainer
    then:
        return false
    return true

# e.g. key "plugin:test" in player's pdc for type byte 
expression [devdinc] %object% [with]in %object%[ for %-object%]: 
    parse:
        set {_key} to expr-1
        set {_pdt} to expr-3
            
        if any:
            "%{_key}%" is "[devdinc] [namespaced]( |-)key %%string%%"
            {_key} is instance of Variable
        then:
            if any:
                "%{_pdt}%" contains "[devdinc] (pdt|[persistent data ]type)"
                "%{_pdt}%" contains "PersistentDataType"
                {_pdt} is instance of Variable
                {_pdt} is not set
            then:
                continue
        stop

    get:
        set {_key} to expr-1
        set {_pdc} to expr-2.getPersistentDataContainer() if expr-2 is instance of PersistentDataHolder else expr-2
        set {_pdt} to expr-3
        
        stop if validate_pdcexpr({_key}, {_pdc}, {_pdt}) is false
            
        if {_pdt} is not set:
            if {_pdc}.has({_key}, PersistentDataType.BYTE_ARRAY) is false:
                return {_none}

            set {_bytes} to {_pdc}.get({_key}, PersistentDataType.BYTE_ARRAY)
            set {_in} to new BukkitObjectInputStream(new ByteArrayInputStream({_bytes}))
            set {_obj} to {_in}.readObject()
            {_in}.close()
            return {_obj}
        else:
            return {_pdc}.get({_key}, {_pdt})

    set:
        set {_key} to expr-1
        set {_pdc} to expr-2.getPersistentDataContainer() if expr-2 is instance of PersistentDataHolder else expr-2
        set {_pdt} to expr-3
        
        stop if validate_pdcexpr({_key}, {_pdc}, {_pdt}) is false
        
        set {_value} to change value
        
        if any:
            {_value} is null
            {_value} is not set
        then:
            {_pdc}.remove({_key})
            stop

        if {_pdt} is not set:
            set {_baos} to new ByteArrayOutputStream()
            set {_out} to new BukkitObjectOutputStream({_baos})
            {_out}.writeObject({_value})
            {_out}.close()
            
            set {_boxedBytes::*} to ...{_baos}.toByteArray()
            set {_bytes} to new byte[size of {_boxedBytes::*}]
            loop {_boxedBytes::*}:
                set {_bytes}[loop-index parsed as number - 1] to loop-value
                
            {_pdc}.set({_key}, PersistentDataType.BYTE_ARRAY, {_bytes})

        else:
            {_pdc}.set({_key}, {_pdt}, {_value})

    delete:
        set {_key} to expr-1
        set {_pdc} to expr-2.getPersistentDataContainer() if expr-2 is instance of PersistentDataHolder else expr-2
        set {_pdt} to expr-3
        
        stop if validate_pdcexpr({_key}, {_pdc}, {_pdt}) is false
        
        {_pdc}.remove({_key})

expression [devdinc] [namespaced]( |-)key %string%:
    parse:
        continue
    get:
        return NamespacedKey.fromString(expr-1, null)
        
object property p[ersistent ]d[ata ]c[ontainer]:
    parse:
        continue
    get:
        return expr-1.getPersistentDataContainer()

expression [devdinc] (pdt|[persistent data ]type) (1:str[ing]|2:int[eger]|3:long|4:float|5:double|6:byte|7:short|8:bool[ean]):
    parse:
        continue
    get:
        if parse mark is 1:
            return PersistentDataType.STRING
        else if parse mark is 2:
            return PersistentDataType.INTEGER
        else if parse mark is 3:
            return PersistentDataType.LONG
        else if parse mark is 4:
            return PersistentDataType.FLOAT
        else if parse mark is 5:
            return PersistentDataType.DOUBLE
        else if parse mark is 6:
            return PersistentDataType.BYTE
        else if parse mark is 7:
            return PersistentDataType.SHORT
        else if parse mark is 8:
            return PersistentDataType.BOOLEAN
        else:
            return {_none}

