import:
    java.util.function.Supplier
    java.util.function.Function
    java.util.function.Consumer
    java.util.function.BiFunction
    java.util.function.BiConsumer
    java.lang.Runnable
    ch.njol.skript.lang.ExpressionList
    ch.njol.skript.lang.Variable
    ch.njol.skript.Skript
    ch.njol.skript.lang.EffectSection
    ch.njol.skript.lang.function.EffFunctionCall
    ch.njol.skript.lang.SkriptParser
    ch.njol.skript.log.SkriptLogger
    ch.njol.skript.lang.EffectSectionEffect
    org.skriptlang.skript.registration.SyntaxRegistry

local function FextractArgs(vars: object) :: objects:
    if {_vars} is instance of ExpressionList:
        loop ...{_vars}.getExpressions():
            add loop-value to {_ret::*}
    else if {_vars} is instance of Variable:
        add {_vars} to {_ret::*}
    return {_ret::*}

local function isEffect(input:string) :: boolean:
    set {_ob} to parseEffectSilent({_input})
    if {_ob} is not set:
        return false
    return true

local function getFunctionReference(call: object) :: object:
    set {_class} to {_call}.getClass()
    set {_field} to {_class}.getDeclaredField("function")
    {_field}.setAccessible(true)
    return {_field}.get({_call})

# equals effect.parse 
local function parseEffectSilent(input: string) :: object:
    set {_log} to SkriptLogger.startParseLogHandler()
    set {_func} to EffFunctionCall.parse({_input})
    if {_func} is set:
        set {_ref} to getFunctionReference({_func})
        if {_ref}.getReturnType() is set:
            {_log}.close()
            return {_none}
        {_log}.close()
        return {_func}
    set {_section} to EffectSection.parse({_input}, null, null, null)
    if {_section} is set:
        {_log}.close()
        return new EffectSectionEffect({_section})
    set {_registry} to Skript.instance().syntaxRegistry()
    set {_iterator} to {_registry}.syntaxes(SyntaxRegistry.EFFECT).iterator()
    set {_effect} to SkriptParser.parse({_input}, {_iterator}, null)
    {_log}.clear()
    {_log}.close()
    return {_effect}
    
expression build lambda args %objects% body %string% noreturn %boolean% script %script%:
    get:
        set {_functionsv2.sk::ctx::args::*} to expr-1
        set {_functionsv2.sk::ctx::body} to expr-2
        set {_functionsv2.sk::ctx::noreturn} to expr-3
        set {_functionsv2.sk::ctx::script} to expr-4
        set {_functionsv2.sk::ctx::arity} to size of {_functionsv2.sk::ctx::args::*}
        if {_functionsv2.sk::ctx::noreturn} is true:
            if {_functionsv2.sk::ctx::arity} is 0:
                set {_functionsv2.sk::ctx::functions::run} to line section {_functionsv2.sk::ctx::body} with args {_this}
                set {_functionsv2.sk::ctx::proxy} to new proxy instance of Runnable using {_functionsv2.sk::ctx::functions::*}
            else if {_functionsv2.sk::ctx::arity} is 1:
                set {_functionsv2.sk::ctx::proxy} to raw expression of {_this}
                set {_functionsv2.sk::ctx::functions::accept} to line section {_functionsv2.sk::ctx::body} with args "%{_functionsv2.sk::ctx::proxy}%", "%{_functionsv2.sk::ctx::args::1}%" in {_functionsv2.sk::ctx::script}
                set {_functionsv2.sk::ctx::proxy} to new proxy instance of Consumer using {_functionsv2.sk::ctx::functions::*}
            else:
                set {_functionsv2.sk::ctx::proxy} to raw expression of {_this}
                set {_functionsv2.sk::ctx::functions::accept} to line section {_functionsv2.sk::ctx::body} with args "%{_functionsv2.sk::ctx::proxy}%", "%{_functionsv2.sk::ctx::args::1}%", "%{_functionsv2.sk::ctx::args::2}%" in {_functionsv2.sk::ctx::script}
                set {_functionsv2.sk::ctx::proxy} to new proxy instance of BiConsumer using {_functionsv2.sk::ctx::functions::*}
        else:

            if {_functionsv2.sk::ctx::arity} is 0:
                set {_functionsv2.sk::ctx::functions::get} to line section "return %{_functionsv2.sk::ctx::body}%" with args {_this} in {_functionsv2.sk::ctx::script}
                set {_functionsv2.sk::ctx::proxy} to new proxy instance of Supplier using {_functionsv2.sk::ctx::functions::*}
            else if {_functionsv2.sk::ctx::arity} is 1:
                set {_functionsv2.sk::ctx::proxy} to raw expression of {_this}
                set {_functionsv2.sk::ctx::functions::apply} to line section "return %{_functionsv2.sk::ctx::body}%" with args "%{_functionsv2.sk::ctx::proxy}%", "%{_functionsv2.sk::ctx::args::1}%" in {_functionsv2.sk::ctx::script}
                set {_functionsv2.sk::ctx::proxy} to new proxy instance of Function using {_functionsv2.sk::ctx::functions::*}
            else:
                set {_functionsv2.sk::ctx::proxy} to raw expression of {_this}
                set {_functionsv2.sk::ctx::functions::apply} to line section "return %{_functionsv2.sk::ctx::body}%" with args "%{_functionsv2.sk::ctx::proxy}%", "%{_functionsv2.sk::ctx::args::1}%", "%{_functionsv2.sk::ctx::args::2}%" in {_functionsv2.sk::ctx::script}
                set {_functionsv2.sk::ctx::proxy} to new proxy instance of BiFunction using {_functionsv2.sk::ctx::functions::*}
        return {_functionsv2.sk::ctx::proxy}

expression:
    patterns:
        lambda[ %-objects%]\:(1: |2:- |3:+ )<(.+)>
    parse:
        set {_functionsv2.sk::ctx::vars} to expr-1
        set {_functionsv2.sk::ctx::expr} to first element of regex-1
        set {_functionsv2.sk::ctx::noreturn} to isEffect({_functionsv2.sk::ctx::expr}) if parse mark is 1
        set {_functionsv2.sk::ctx::noreturn} to true if parse mark is 2
        set {_functionsv2.sk::ctx::noreturn} to false if parse mark is 3
        set {_functionsv2.sk::ctx::args::*} to FextractArgs({_functionsv2.sk::ctx::vars})
        set {_functionsv2.sk::ctx::origin} to SkriptLogger.getNode()
        set {_functionsv2.sk::ctx::script} to script ({_functionsv2.sk::ctx::origin}.getConfig().getFileName())
        if {_functionsv2.sk::ctx::script} is not set: # likely inner lambda
            set {_functionsv2.sk::ctx::script} to current script
        continue
    get:
        return build lambda args {_functionsv2.sk::ctx::args::*} body {_functionsv2.sk::ctx::expr} noreturn {_functionsv2.sk::ctx::noreturn} script {_functionsv2.sk::ctx::script}
        
expression:
    patterns:
        (1:supplier|1:getter|2:runnable|2:runner)[ %-objects%]\: <(.+)>
        (3:consumer|3:accepter|4:function|4:applier|5:biconsumer|5:biaccepter|6:bifunction|6:biapplier) %-objects%\: <(.+)>
    parse:
        set {_functionsv2.sk::ctx::vars} to expr-1
        set {_functionsv2.sk::ctx::expr} to first element of regex-1
        set {_functionsv2.sk::ctx::noreturn} to true
        if any:
            parse mark is 1
            parse mark is 4
            parse mark is 6
        then:
            set {_functionsv2.sk::ctx::noreturn} to false
        set {_functionsv2.sk::ctx::args::*} to FextractArgs({_functionsv2.sk::ctx::vars})
        if any:
            parse mark is 1
            parse mark is 2
        then:
            if size of {_functionsv2.sk::ctx::args::*} > 0:
                stop
        if any:
            parse mark is 3
            parse mark is 4
        then:
            if size of {_functionsv2.sk::ctx::args::*} is 0:
                stop
        if any:
            parse mark is 5
            parse mark is 6
        then:
            if size of {_functionsv2.sk::ctx::args::*} is not 2:
                stop
        set {_functionsv2.sk::ctx::origin} to SkriptLogger.getNode()
        set {_functionsv2.sk::ctx::script} to script ({_origin}.getConfig().getFileName())
        if {_functionsv2.sk::ctx::script} is not set: # likely inner lambda
            set {_functionsv2.sk::ctx::script} to current script
        continue
    get:
        return build lambda args {_functionsv2.sk::ctx::args::*} body {_functionsv2.sk::ctx::expr} noreturn {_functionsv2.sk::ctx::noreturn} script {_functionsv2.sk::ctx::script}

expression run[ lambda] %object%[ with %-objects%]:
    get:
        set {_functionsv2.sk::ctx::args::*} to expr-2
        expr-1 is instance of Runnable:
            expr-1.run()
        else if expr-1 is instance of Consumer:
            expr-1.accept(expr-2)
        else if expr-1 is instance of BiConsumer:
            expr-1.accept({_functionsv2.sk::ctx::args::1}, {_functionsv2.sk::ctx::args::2})
        else if expr-1 is instance of Function:
            return expr-1.apply(expr-2)
        else if expr-1 is instance of BiFunction:
            return expr-1.apply({_functionsv2.sk::ctx::args::1}, {_functionsv2.sk::ctx::args::2})
        else if expr-1 is instance of Supplier:
            return expr-1.get()
