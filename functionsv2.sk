# =============================================================================
# REQUIREMENTS
# =============================================================================
#
# Skcrew, skript-reflect
#
# =============================================================================
# LAMBDA EXPRESSION DOCUMENTATION
# =============================================================================
#
# This expression provides lightweight Java-compatible lambda proxies
# (Supplier, Function, BiFunction, Runnable, Consumer, BiConsumer).
#
# -----------------------------------------------------------------------------
# Syntax
# -----------------------------------------------------------------------------
#
# 1) Returning lambda (expressions only):
#
#    lambda [<variables>]: <expression>
#
#    - The body MUST be a single expression.
#    - Effects are NOT allowed.
#    - The value of the expression is implicitly returned.
#
# 2) Non-returning lambda (effects only):
#
#    lambda [<variables>]:- <effect>
#
#    - Used for side effects.
#    - No return value is produced.
#
# -----------------------------------------------------------------------------
# Examples
# -----------------------------------------------------------------------------
#
# Supplier (no arguments, returns a value)
# ----------------------------------------
# set {_supplier} to lambda: "hello"
# broadcast {_supplier}.get()
#
# set {_sum} to lambda: 2 + 3
# broadcast {_sum}.get()
#
# Function (one argument, returns a value)
# ----------------------------------------
# set {_double} to lambda {_x}: {_x} * 2
# broadcast {_double}.apply(5) # 10
#
# set {_format} to lambda {_x}: "%{_x}%_ok"
# broadcast {_format}.apply("abc") # abc_ok
#
# BiFunction (two arguments, returns a value)
# -------------------------------------------
# set {_add} to lambda {_a}, {_b}: {_a} + {_b}
# broadcast {_add}.apply(3, 4) # 7
#
# Runnable (no arguments, no return)
# ----------------------------------
# set {_task} to lambda:- broadcast "ran"
# {_task}.run()
#
# Consumer (one argument, no return)
# ----------------------------------
# set {_printer} to lambda {_x}:- broadcast {_x}
# {_printer}.accept(42)
#
# BiConsumer (two arguments, no return)
# -------------------------------------
# set {_pair} to lambda {_a}, {_b}:- broadcast "%{_a}%, %{_b}%"
# {_pair}.accept("x", "y")
#
# Passing composite data to bypass arity limits
# ----------------------------------------------
# set {_map} to new HashMap()
# {_map}.put(1, 2)
# {_map}.put(2, 3)
#
# set {_adder} to lambda {_m}:- {_m}.values().stream().forEach(lambda {_v}:- add {_v} to {-total})
#
# {_adder}.accept({_map})
#
# -----------------------------------------------------------------------------
# Arity Rules
# -----------------------------------------------------------------------------
#
# - 0 arguments:
#     Supplier<T>  (returning)
#     Runnable     (non-returning)
#
# - 1 argument:
#     Function<T, R>   (returning)
#     Consumer<T>      (non-returning)
#
# - 2 arguments:
#     BiFunction<T, U, R> (returning)
#     BiConsumer<T, U>    (non-returning)
#
# - More than 2 arguments are NOT supported.
#   To work around this, pass a single variable containing a arraylist, map,
#   or other composite object.
#
# -----------------------------------------------------------------------------
# Limitations
# -----------------------------------------------------------------------------
#
# - Lambdas are strictly single-line.
# - Returning lambdas (:) cannot contain effects.
# - Effect lambdas (:-) cannot return values.
# - Imported classes or complex expressions may fail to resolve inline.
#   Mitigation: wrap the logic inside a normal function and call it.
#
# -----------------------------------------------------------------------------
# Notes
# -----------------------------------------------------------------------------
#
# - array lists, maps, and objects may be passed as a single argument
#   to simulate higher arity.
#
# =============================================================================

import:
    java.util.function.Supplier
    java.util.function.Function
    java.util.function.Consumer
    java.util.function.BiFunction
    java.util.function.BiConsumer
    java.lang.Runnable

expression:
    patterns:
        lambda[ %-objects%]\:(1: |2:- )<(.+)>
    parse:
        # -------------------------
        # Capture inputs
        # -------------------------
        set {_HqZr::vars} to "%expr-1%"
        if {_HqZr::vars} is "<none>":
            set {_HqZr::vars} to ""
        set {_HqZr::expr} to first element of regex-1
        set {_HqZr::noreturn} to true if parse mark is 2 else false

        # -------------------------
        # Determine arity
        # -------------------------
        set {_HqZr::arity} to 0
        if {_HqZr::vars} is not "":
            if {_HqZr::vars} contains "and":
                replace "(" with "" in {_HqZr::vars}
                replace ")" with "" in {_HqZr::vars}
                set {_HqZr::args::*} to split {_HqZr::vars} at " and "
                set {_HqZr::arity} to 2
            else:
                set {_HqZr::arg1} to {_HqZr::vars}
                set {_HqZr::arity} to 1

        # -------------------------
        # Emit + bind (NO RETURN)
        # -------------------------
        if {_HqZr::noreturn} is true:

            if {_HqZr::arity} is 0:
                evalnode "create section with {_HqZr::proxy} stored in {_functions::run}:", "  %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of Runnable using {_functions::*}

            else if {_HqZr::arity} is 1:
                evalnode "create section with {_HqZr::proxy}, %{_HqZr::arg1}% stored in {_functions::accept}:", "  %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of Consumer using {_functions::*}

            else:
                evalnode "create section with {_HqZr::proxy}, %{_HqZr::args::1}%, %{_HqZr::args::2}% stored in {_functions::accept}:", "  %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of BiConsumer using {_functions::*}

        # -------------------------
        # Emit + bind (RETURNING)
        # -------------------------
        else:

            if {_HqZr::arity} is 0:
                evalnode "create section with {_HqZr::proxy} stored in {_functions::get}:", "  return %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of Supplier using {_functions::*}

            else if {_HqZr::arity} is 1:
                evalnode "create section with {_HqZr::proxy}, %{_HqZr::arg1}% stored in {_functions::apply}:", "  return %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of Function using {_functions::*}

            else:
                evalnode "create section with {_HqZr::proxy}, %{_HqZr::args::1}%, %{_HqZr::args::2}% stored in {_functions::apply}:", "  return %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of BiFunction using {_functions::*}

        continue

    get:
        return {_HqZr::proxy}
