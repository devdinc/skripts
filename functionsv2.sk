# =============================================================================
# REQUIREMENTS
# =============================================================================
#
# Skcrew, skript-reflect
#
# =============================================================================
# LAMBDA EXPRESSION DOCUMENTATION
# =============================================================================
#
# This expression provides lightweight Java-compatible lambda proxies
# (Supplier, Function, BiFunction, Runnable, Consumer, BiConsumer).
#
# -----------------------------------------------------------------------------
# Syntax
# -----------------------------------------------------------------------------
#
# 1) Returning lambda (expressions only):
#
#    lambda [<variables>]: <expression/effect>
#
#    - The body MUST be a single expression or an effect.
#    - The value of the expression is implicitly returned.
#
# 2) Non-returning lambda (effects only):
#
#    lambda [<variables>]:- <effect>
#
#    - Used for side effects.
#    - No return value is produced.
#
# -----------------------------------------------------------------------------
# Examples
# -----------------------------------------------------------------------------
#
# Supplier (no arguments, returns a value)
# ----------------------------------------
# set {_supplier} to lambda: "hello"
# broadcast {_supplier}.get()
#
# set {_sum} to lambda: 2 + 3
# broadcast {_sum}.get()
#
# Function (one argument, returns a value)
# ----------------------------------------
# set {_double} to lambda {_x}: {_x} * 2
# broadcast {_double}.apply(5) # 10
#
# set {_format} to lambda {_x}: "%{_x}%_ok"
# broadcast {_format}.apply("abc") # abc_ok
#
# BiFunction (two arguments, returns a value)
# -------------------------------------------
# set {_add} to lambda {_a}, {_b}: {_a} + {_b}
# broadcast {_add}.apply(3, 4) # 7
#
# Runnable (no arguments, no return)
# ----------------------------------
# set {_task} to lambda:- broadcast "ran"
# {_task}.run()
#
# Consumer (one argument, no return)
# ----------------------------------
# set {_printer} to lambda {_x}:- broadcast {_x}
# {_printer}.accept(42)
#
# BiConsumer (two arguments, no return)
# -------------------------------------
# set {_pair} to lambda {_a}, {_b}:- broadcast "%{_a}%, %{_b}%"
# {_pair}.accept("x", "y")
#
# Passing composite data to bypass arity limits
# ----------------------------------------------
# set {_map} to new HashMap()
# {_map}.put(1, 2)
# {_map}.put(2, 3)
#
# set {_adder} to lambda {_m}:- {_m}.values().stream().forEach(lambda {_v}:- add {_v} to {-total})
#
# {_adder}.accept({_map})
#
# -----------------------------------------------------------------------------
# Arity Rules
# -----------------------------------------------------------------------------
#
# - 0 arguments:
#     Supplier<T>  (returning)
#     Runnable     (non-returning)
#
# - 1 argument:
#     Function<T, R>   (returning)
#     Consumer<T>      (non-returning)
#
# - 2 arguments:
#     BiFunction<T, U, R> (returning)
#     BiConsumer<T, U>    (non-returning)
#
# - More than 2 arguments are NOT supported.
#   To work around this, pass a single variable containing a arraylist, map,
#   or other composite object.
#
# -----------------------------------------------------------------------------
# Limitations
# -----------------------------------------------------------------------------
#
# - Lambdas are strictly single-line.
# - Returning lambdas (:) cannot contain effects.
# - Effect lambdas (:-) cannot return values.
# - Imported classes or complex expressions may fail to resolve inline.
#   Mitigation: wrap the logic inside a normal function and call it.
#
# -----------------------------------------------------------------------------
# Notes
# -----------------------------------------------------------------------------
#
# - array lists, maps, and objects may be passed as a single argument
#   to simulate higher arity.
# - array is buggy, you have to spread(...) inside lambda to use it, as [n]
#   does not work
# - variable lists as parameters never work.
#
# =============================================================================

import:
    java.util.function.Supplier
    java.util.function.Function
    java.util.function.Consumer
    java.util.function.BiFunction
    java.util.function.BiConsumer
    java.lang.Runnable
    ch.njol.skript.lang.ExpressionList
    
local function isEffect(input:string) :: boolean:
    set {_ob} to parseEffectSilent({_input})
    if {_ob} is not set:
        return false
    return true
    
import:
    ch.njol.skript.Skript
    ch.njol.skript.lang.EffectSection
    ch.njol.skript.lang.function.EffFunctionCall
    ch.njol.skript.lang.SkriptParser
    ch.njol.skript.log.SkriptLogger
    ch.njol.skript.lang.EffectSectionEffect
    org.skriptlang.skript.registration.SyntaxRegistry
    
local function getFunctionReference(call: object) :: object:
    set {_class} to {_call}.getClass()
    set {_field} to {_class}.getDeclaredField("function")
    {_field}.setAccessible(true)
    return {_field}.get({_call})

# equals effect.parse 
local function parseEffectSilent(input: string) :: object:
    # we use a logger to remove stupid useless 1 + 1 is not a java object calls
    # this is safe enough for prod since evalnode parses it.
    set {_log} to SkriptLogger.startParseLogHandler()

    # 1. Function calls
    set {_func} to EffFunctionCall.parse({_input})
    if {_func} is set:
        set {_ref} to getFunctionReference({_func})

        # Has return → expression-like
        if {_ref}.getReturnType() is set:
            {_log}.close()
            return {_none} # treat as expression

        # No return → effect-only
        {_log}.close()
        return {_func}

    # 2. Effect sections
    set {_section} to EffectSection.parse({_input}, null, null, null)
    if {_section} is set:
        {_log}.close()
        return new EffectSectionEffect({_section})

    # 3. Normal effects
    set {_registry} to Skript.instance().syntaxRegistry()
    set {_iterator} to {_registry}.syntaxes(SyntaxRegistry.EFFECT).iterator()
    set {_effect} to SkriptParser.parse({_input}, {_iterator}, null)
    {_log}.clear()
    {_log}.close()
    
    return {_effect}
    

expression:
    patterns:
        lambda[ %-objects%]\:(1: |2:- )<(.+)>
    parse:
        # -------------------------
        # Capture inputs
        # -------------------------
        set {_HqZr::vars} to expr-1
        set {_HqZr::expr} to first element of regex-1
        set {_HqZr::noreturn} to isEffect({_HqZr::expr})
        set {_HqZr::noreturn} to true if parse mark is 2

        # -------------------------
        # Determine arity
        # -------------------------
        set {_HqZr::arity} to 0
        if {_HqZr::vars} is set:
            if expr-1 is instance of ExpressionList:
                # we cant loop since this is parse time...
                # it doesnt matter as who uses (/)/" and " inside vars anyways.
                set {_HqZr::vars} to "%{_HqZr::vars}%"
                replace "(" with "" in {_HqZr::vars}
                replace ")" with "" in {_HqZr::vars}
                set {_HqZr::args::*} to split {_HqZr::vars} at " and "
                set {_HqZr::arity} to 2
            else:
                set {_HqZr::arg1} to "%{_HqZr::vars}%"
                set {_HqZr::arity} to 1

        # -------------------------
        # Emit + bind (NO RETURN)
        # -------------------------
        if {_HqZr::noreturn} is true:

            if {_HqZr::arity} is 0:
                evalnode "create section with {_HqZr::proxy} stored in {_functions::run}:", "  %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of Runnable using {_functions::*}

            else if {_HqZr::arity} is 1:
                evalnode "create section with {_HqZr::proxy}, %{_HqZr::arg1}% stored in {_functions::accept}:", "  %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of Consumer using {_functions::*}

            else:
                evalnode "create section with {_HqZr::proxy}, %{_HqZr::args::1}%, %{_HqZr::args::2}% stored in {_functions::accept}:", "  %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of BiConsumer using {_functions::*}

        # -------------------------
        # Emit + bind (RETURNING)
        # -------------------------
        else:

            if {_HqZr::arity} is 0:
                evalnode "create section with {_HqZr::proxy} stored in {_functions::get}:", "  return %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of Supplier using {_functions::*}

            else if {_HqZr::arity} is 1:
                evalnode "create section with {_HqZr::proxy}, %{_HqZr::arg1}% stored in {_functions::apply}:", "  return %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of Function using {_functions::*}

            else:
                evalnode "create section with {_HqZr::proxy}, %{_HqZr::args::1}%, %{_HqZr::args::2}% stored in {_functions::apply}:", "  return %{_HqZr::expr}%"
                set {_HqZr::proxy} to new proxy instance of BiFunction using {_functions::*}

        continue

    get:
        return {_HqZr::proxy}
