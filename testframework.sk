using reflection

import:
    ch.njol.skript.lang.parser.ParserInstance
    org.bukkit.Bukkit
    ch.njol.skript.test.utils.TestOfflinePlayer
    ch.njol.skript.lang.Condition

local effect testFail %string%[, %-string%]:
    trigger:
        set {_msg} to " %expr-2%" if expr-2 is set else ""
        send "[<gold>Skript<reset>] [&cTEST FAILURE<reset>] %expr-1%%{_msg}%" to console

event "skriptTest":
    pattern: test %string% [when <(.+)>]
    event-values: string, boolean
    check:
        set {_ok} to true
        set {-test.sk::tests::%current script%::%expr-1%} to "%expr-1%"
        if "%current script%/%expr-1%" is event-string:
            set {_raw} to first element of regex-1
            if {_raw} is set:
                set {_cond} to Condition.parse({_raw}, "Can't understand condition: " + {_raw})
        
            if {_cond} is set:
                set {_ok} to {_cond}.check(event)
            continue if {_ok} is true

plural expression all tests [with test name %-string%] [([with]in|from) %-script%]:
    return type: strings
    parse:
        set {_scoped} to false if expr-2 is not set
        continue

    get:
        if {_scoped} is false:
            loop indices of {-test.sk::tests::*}:
                loop {-test.sk::tests::%loop-value%::*}:
                    if any:
                        expr-1 is not set
                        loop-value-2 is expr-1
                    then:
                        add "%loop-value-1%/%loop-value-2%" to {_r::*}

        else:
            if expr-1 is not set:
                loop {-test.sk::tests::%expr-2%::*}:
                    add "%expr-2%/%loop-value%" to {_r::*}
            else if {-test.sk::tests::%expr-2%::%expr-1%} is set:
                add "%expr-2%/%expr-1%" to {_r::*}

        return {_r::*}
        
effect (1:|2:auto)run [test][s] %strings%:
    trigger:
        set {_tests::*} to expr-1
        set {_alltests::*} to all tests
        loop {_tests::*}:
            delete {-test.sk::errors::%loop-value%::*} 
            set {_list::string} to loop-value
            set {_list::boolean} to true if parse mark is 2 else false
            call custom event "skriptTest" with {_list::*}
            if any:
                loop-value contains "f39f0f4a-31ee-4b71-87e9-38ddba3a2313"
                {_alltests::*} does not contain loop-value
            then:
                add 1 to {_forgottenTestResults}
                continue loop
            add 1 to {_testFails} if size of {-test.sk::errors::%loop-value%::*} is greater than 0
        set {_validTestAmount} to size of {_tests::*} - {_forgottenTestResults}
        if {_validTestAmount} is not 0:
            send "[<gold>Skript<reset>] <yellow>%{_validTestAmount} - {_testFails}%/%{_validTestAmount}% tests passed." to console
        else if size of {_alltests::*} is greater than 0: # skipping if there is no initial hidden test 
            send "[<gold>Skript<reset>] <yellow>No tests found." to console

on load:
    delete {-test.sk::*}
    set {_block} to test-block's type
    wait 1 tick
    run test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313"
    wait 1 tick
    set {_tests::*} to all tests
    autorun {_tests::*}
    set test-block to {_block}
    broadcast "<red>Test block is permanent!" if test-block is not {_block}

effect:
    patterns:
        (3:|4:(no|without) (halt[ing]|fail[(-| )](safe|fast)|abort[ing])) assert(1:|1: true|2: false)[ with (6:|5:no )[[error] message][ %-string%]]\: <(.+)>
        (3:|4:(no|without) (halt[ing]|fail[(-| )](safe|fast)|abort[ing])) assert <(.+)> (1:|2:to fail)[ with (6:|5:no )[[error][ message]][ %-string%]]
    usable in:
        custom event "skriptTest"
    parse:
        set {_raw} to first element of regex-1
        
        set {_parser} to ParserInstance.get()
        set {_parser}.[ParserInstance]isActive to true
        set {_backup} to {_parser}.backup()  
        
        {_parser}.setCurrentScript(current script)
        {_parser}.setCurrentEvent("assert condition", (custom event "skriptTest").getClass())
        
        set {_cond} to Condition.parse({_raw}, "Can't understand condition: " + {_raw})
        
        set {_parser}.[ParserInstance]isActive to false
        {_parser}.restoreBackup({_backup})  
        continue
    trigger:
        set {_ok} to {_cond}.check(event)
        
        set {_label} to "assert true" if parse tags contains "1" else "assert false"
        set {_test} to event.getEventValue("string")
        if all:
            parse tags contains "1"
            {_ok} is false
        then:
            set {_bool1} to true
            
        if all:
            parse tags contains "2"
            {_ok} is true
        then:
            set {_bool2} to true
            
        if any:
            {_bool1} is true
            {_bool2} is true
        then:
            if parse tags does not contain "5":
                testFail "Test ""%{_test}%"" with condition ""%{_label}%: %{_raw}%"" failed", expr-1
            add "%expr-1%" to {-test.sk::errors::%{_test}%::*}
            if parse tags contains "3":
                delay effect

effect (3:|4:(no|without) (halt[ing]|fail[(-| )](safe|fast)|abort[ing])) fail test[ with (6:|5:no )[[error] message][ %-string%]]:
    usable in: 
        custom event "skriptTest"
    trigger:
        set {_test} to event.getEventValue("string")
        if parse tags does not contain "5":
            testFail "Test ""%{_test}%"" failed", expr-1
        add "%expr-1%" to {-test.sk::errors::%{_test}%::*}
        if parse tags contains "3":
            delay effect
        
effect stop auto [test] execution [here]:
    usable in:
        custom event "skriptTest"
    trigger:
        set {_bool} to event.getEventValue("boolean")
        if {_bool} is true:
            delay effect
            
expression [event(-| )]test:
    return type: string
#    usable in:
#        custom event "skriptTest"
    get:
        return event.getEventValue("string")
        
condition %string% (1:is|2:is not|2:isn't) autorun:
    # usable in:
    #    custom event "skriptTest"
    check:
        set {_bool} to event.getEventValue("boolean")
        if {_bool} is true:
            parse mark is 1
            continue
        else:
            parse mark is 2
            continue
            
### this section is experimental.

import:
    ch.njol.skript.ScriptLoader
    ch.njol.skript.log.SkriptLogger
            
condition parse:
    parse:
        set {_parser} to ParserInstance.get()
        set {_parseSection} to {_parser}.getNode()
        set {_parseBackup} to {_parser}.backup()
        # nodes are not fully loaded here yet
        continue
    usable in:
        custom event "skriptTest"
    check:
        {_parser}.restoreBackup({_parseBackup})
        set {_logger} to SkriptLogger.startRetainingLog()
        ScriptLoader.loadItems({_parseSection})
        loop ...{_logger}.getLog():
            add loop-value.getMessage() to {_logs::*}
        set {-test.sk::latestLogs::*} to {_logs::*}
        {_logger}.close()
        {_parser}.reset()
        
local effect no errors\: <.+>:
    trigger:
        stop

plural expression latest parse logs:
    usable in:
        custom event "skriptTest"
    get:
        return {-test.sk::latestLogs::*}

# ----

plural expression test errors[ for [test[s]] %-strings%]:
    return type: strings
    get:
        if expr-1 is not set:
            set {_test} to event.getEventValue("string")
            return {-test.sk::errors::%{_test}%::*}
        else:
            loop ...expr-1:
                set {_test} to loop-value
                add {-test.sk::errors::%{_test}%::*} to {_r::*}
            return {_r::*}

expression [the] test(-| )world:
    return type: world
    get:
        return Bukkit.getWorlds().get(0)

expression [the] test(-| )location:
    return type: location
    get:
        return test-world.getSpawnLocation().add(10, 1, 0)

expression [the] test(-| )block:
    return type: block
    get:
        return test-location.getBlock()
    set:
        set block at test-location to change value
        
expression [the] test(-| )offline[-| ]player:
    return type: offlineplayer
    get:
        set {_instance} to new TestOfflinePlayer()
        # TestOfflinePlayer.[TestOfflinePlayer]PLAYER_PROFILE.setProperty(new ProfileProperty("textures", "ewogICJ0aW1lc3RhbXAiIDogMTc0NzQyOTg2MTQwOCwKICAicHJvZmlsZUlkIiA6ICI2OWUzNzAyNjJjN2Q0MjU1YWM3NjliMTNhNWZlOGY3NCIsCiAgInByb2ZpbGVOYW1lIiA6ICJTYWh2ZGUiLAogICJzaWduYXR1cmVSZXF1aXJlZCIgOiB0cnVlLAogICJ0ZXh0dXJlcyIgOiB7CiAgICAiU0tJTiIgOiB7CiAgICAgICJ1cmwiIDogImh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvNTE2MGFiZWVhNDI1YzZmODMyYjc0NmE0NTQ0YzVmYjlhOTgxYjAyZTFiZDg1ZmVhNWM3ZWY4MzFiZGM4NzRmMyIKICAgIH0KICB9Cn0="));
        return {_instance}

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 assert true passes":
    assert true: {_none} is not set

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 assert false passes":
    assert false: {_none} is set
    
test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 framework internal consistency":
    without halting assert true: size of all tests > 0
    without halting assert true: "%current script%" is set
    assert true: size of test errors is 0


test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 assert true failure is recorded":
    without halting assert true with no error message: {_none} is set
    assert true: size of test errors is 1
    
test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 assert error message is stored":
    without halting assert true with no error message "msg1": {_none} is set
    assert true with message "check failed": test errors contains "msg1"

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 no error message produces empty suffix":
    without halting assert true with no error message: {_none} is set
    assert true: size of test errors is 1

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 halting assert stops execution":
    assert true with no error message: {_none} is set
    broadcast "<red>ERROR: this should never execute"

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 without halting continues execution":
    without halting assert true with no error message: {_none} is set
    assert true: {_none} is not set

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 fail test records error":
    without halting fail test with no error message
    assert true: size of test errors is 1

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 fail test halts by default":
    fail test with no error message
    broadcast "<red>ERROR: fail test did not halt"

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 autorun flag is true":
    assert true: event-test is autorun

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 manual run flag is false" when {_none} is set:
    fail test
    
test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 manual run flag" when event-test is not autorun:
    fail test

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 stop auto execution works":
    stop auto test execution here
    broadcast "<red>ERROR: auto execution not stopped"

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 all tests returns this test":
    set {_all::*} to all tests
    assert true: {_all::*} contains "%current script%/f39f0f4a-31ee-4b71-87e9-38ddba3a2313 all tests returns this test"

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 all tests scoped by script":
    set {_all::*} to all tests within current script
    assert true: size of {_all::*} > 0

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 errors do not leak between tests A":
    without halting assert true with no message: {_none} is set
    assert true: size of test errors is 1

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 errors do not leak between tests B":
    assert true: size of test errors is 0

test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 event-test returns correct name":
    assert true: event-test is event-string
    
test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 test-block is temporary":
    test block is chest:
        set test-block to trapped chest
    else if test block is trapped chest:
        set test-block to chest
    else:
        set test-block to ender chest
        
    # test is continued at on load end
    
test "f39f0f4a-31ee-4b71-87e9-38ddba3a2313 parse section":
    parse:
        no errors: abc # just an internal stuff to make sure test.sk loads without errors
    assert latest parse logs contains "Can't understand this condition/effect: no errors: abc"


